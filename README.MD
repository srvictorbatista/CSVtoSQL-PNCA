
<p align="center">
    <a href="#PNCA">
        <img src="https://i.postimg.cc/hjnK7xHV/stand.png" alt="CSV-SQL PNCA">
    </a>
</p>
<h1 align="center">PNCA: Script de convers√£o de CSV para SQL</h1>
<h2>WANTED: No pandas, no bamboo. Just trees and data. Because pandas don't eat trees.</h2>

**Contexto e Significado**: O subt√≠tulo faz uma brincadeira sobre um "Panda foragido" enfatizando a aus√™ncia de "bambu". Refer√™ncia ao fato de que pandas (os ursos) s√≥ comem bambu, mas esse projeto, para fins de conceito e did√°tica. Evita a biblioteca Pandas (que trata os dados de forma vertical, como um bambu, que por sinal, √© um tipo de grama/relva). A express√£o "Just trees and data" deixa claro que o foco √© em manipula√ß√£o de dados, sem o uso da biblioteca Pandas. At√© porque como veremos, a abordagem proposta (algoritmo de manipula√ß√£o e classifica√ß√£o) se estende para al√©m da linguagem python. Como exemplo adicional (mas n√£o limitando-se a ela), veremos um exemplo em PHP.

**Descri√ß√£o do Projeto**: O projeto recebe dados brutos, analisa e gera scripts SQL, compat√≠vel com bancos de dados MySQL e Postgres. Ele se baseia em √°rvores de decis√£o para manipula√ß√£o, analise e classifica√ß√£o de dados estruturais para lidar com os dados, ao inv√©s de recorrer a biblioteca "Pandas".
O produto final √© um script SQL compat√≠vel de forma r√°pida e autom√°tica. Que pode ser tanto subdividido em lotes, sem perder a atomicidade (o que lhe permite ajustar a sa√≠da √† carga suportada do servidor), audit√°vel (devido a sua f√°cil leitura, edi√ß√£o, endenta√ß√£o e compreens√£o).
A sa√≠da tamb√©m incorpora um **"CREATE IF NOT EXISTS"** estruturado de forma autom√°tica, recursiva e revers√≠vel. Portanto, segura. Garantindo que nenhum dado se perca, durante todo o processo. Mais detalhes de como isto ocorre, veremos no decorrer desta proposta.

**Ambiente**: O ambiente utilizado para desenvolvimento e testes foi **Python 3.10.11** e **PHP 8.2.28**. 
Se preferir uma vers√£o completa e pronta para uso, de todo o ambiente utilizado, em um √∫nico container docker. Voc√™ poder√° usar o projeto **[TSMX-ETL](https://github.com/srvictorbatista/tsmx-etl)** ofertado pelo mesmo autor.



## üß† Detec√ß√£o Autom√°tica de Tipo de Coluna (an√°lise sint√°tica)

### üìå detect_column_type(); 
**Objetivo**
Estas fun√ß√µes t√™m como objetivo **analisar uma amostra de dados de uma coluna** (lista de valores) e **inferir automaticamente o tipo de dado** mais adequado (por exemplo: inteiro, texto, booleano, data, etc.), considerando diferentes SGBDs (MySQL e PostgreSQL).



### üßÆ √Årvores de Decis√£o

üìÑ Esta fun√ß√£o simula uma √°rvore de decis√£o de forma impl√≠cita:

* Cada condicional representa um n√≥ de decis√£o;
* As regras s√£o aplicadas em sequ√™ncia, classificando cada valor;
* A contagem final determina a classe "vencedora" por peso.

Trata-se de uma √°rvore de decis√£o, onde as regras s√£o expl√≠citas, em vez de amostrais. 

---
_Ambas as fun√ß√µes s√£o uteis e eficientes para inferir (pesar) e classificar tipos de dado, especialmente em processos de **importa√ß√£o de dados (ETL) audit√°veis**, em **transa√ß√µes atomizadas** em blocos de **tamanho regul√°vel**. Embora a vers√£o da fun√ß√£o em Python ofere√ßa uma detec√ß√£o mais robusta, se considerando exclusivamente, o algoritmo  de classifica√ß√£o dos pesos. A op√ß√£o em PHP √© menos verbosa e direta. O que **n√£o significa**, menos eficaz ou mais lenta. Especialmente se considerarmos a escalabilidade, portabilidade e versatilidade das aplica√ß√µes em ambos os casos._

Isto sem falar que uma vez entendendo a l√≥gica usada para a classifica√ß√£o. Esta poder√° ser facilmente adaptada para atender quaisquer atividades, eventualmente n√£o mapeadas. Por isso, vamos a l√≥gica:

--- 
<br> &nbsp;

### üêç Vers√£o em Python: `detect_column_type(values, sgbd)`

#### Descri√ß√£o:

```python
def detect_column_type(values, sgbd):
```

* Parametros:

  * `values`: uma lista de strings representando os valores de uma coluna;
  * `sgbd`: o nome do Sistema Gerenciador de Banco de Dados (ex: 'mysql', 'postgres').

```python
    bool_set = {'true', 'false', 'yes', 'no', 'sim', 'n√£o', '0', '1'}
```

* Define um conjunto de strings representando poss√≠veis valores booleanos.

```python
    non_empty_values = [v.strip().lower() for v in values if v.strip()]
```

* Remove espa√ßos e ignora valores vazios, convertendo tudo para min√∫sculo.

```python
    type_balance = {'boolean': 0, 'date': 0, 'integer': 0, 'float': 0, 'text': 0}
```

* Inicializa um dicion√°rio que servir√° como "placar" de pesos, para contar quantas vezes cada tipo foi detectado.

```python
    for v in non_empty_values:
```

* Itera sobre os valores n√£o vazios.

```python
        if v in bool_set:
            type_balance['boolean'] += 1
```

* Se o valor est√° no conjunto booleano, conta como booleano.

```python
        elif v.lstrip('0') != v and len(v) > 1:
            type_balance['text'] += 1
```

* Detecta poss√≠veis n√∫meros com zero √† esquerda (como "0123"), classificando como texto.

```python
        elif v.replace(',', '.').replace('.', '', 1).isdigit():
            type_balance['float' if '.' in v or ',' in v else 'integer'] += 1
```

* Verifica se o valor √© num√©rico (inteiro ou decimal).

```python
        elif re.match(r'^\d{4}-\d{2}-\d{2}$', v):
            type_balance['date'] += 1
```

* Verifica se o valor est√° no formato ISO de data (AAAA-MM-DD).

```python
        else:
            try:
                parse_date(v, dayfirst=True)
                type_balance['date'] += 1
            except:
                type_balance['text'] += 1
```

* Tenta parsear como data (ex: "dd/mm/YYYY"). Se falhar, assume que √© texto.

```python
    best_type = max(type_balance, key=type_balance.get) if len(non_empty_values) == 0 or type_balance[max(type_balance, key=type_balance.get)] / len(non_empty_values) >= 0.8 else 'text'
```

* Define o tipo final com base no tipo que obteve mais "saldo/peso" e se for representativo (>=80% dos dados).

```python
    return {
        'mysql': {'boolean': 'BOOLEAN', 'date': 'DATE', 'integer': 'INT', 'float': 'FLOAT', 'text': 'TEXT'},
        'postgres': {'boolean': 'BOOLEAN', 'date': 'DATE', 'integer': 'INTEGER', 'float': 'REAL', 'text': 'TEXT'}
    }.get(sgbd, {}).get(best_type, 'TEXT')
```

* Mapeia o tipo gen√©rico para o tipo real do SGBD. Se n√£o reconhecido, retorna TEXT como fallback (medida de seguran√ßa). Que tamb√©m atuar√° em caso de falha na classifica√ß√£o evitando a perda de dados.

---



### üêò Vers√£o em PHP: `detect_column_type($values, $SGBD)`

#### Descri√ß√£o:

```php
function detect_column_type($values, $SGBD) {
```

* Define parametros:

  * `$values`: array de valores da coluna;
  * `$SGBD`: tipo do banco de dados ('mysql', 'postgres').

```php
    $isNumeric = true;
    $isText = false;
```

* Flags para sondar se os valores s√£o num√©ricos e/ou texto.

```php
    foreach ($values as $value){
```

* Itera sobre todos os valores.

```php
        if (is_numeric($value)) continue;
```

* Se for n√∫mero, segue para o pr√≥ximo.

```php
        $isNumeric = false;
        if (strlen($value) > 0) $isText = true;
    }
```

* Se n√£o for num√©rico, marca que n√£o √© n√∫mero. Se for string n√£o vazia, marca que √© texto.

```php
    if ($SGBD == "mysql"){
        return $isNumeric ? 'INT' : ($isText ? 'VARCHAR(255)' : 'TEXT');
```

* Para MySQL:

  * Se tudo √© n√∫mero, retorna INT;
  * Se h√° texto, VARCHAR(255);
  * Caso contr√°rio, TEXT.

```php
    }elseif($SGBD == "postgres"){
        return $isNumeric ? 'INTEGER' : ($isText ? 'VARCHAR(255)' : 'TEXT');
```

* L√≥gica semelhante para compatibilidade com PostgreSQL.

```php
    }else{
        return 'TEXT';
    }
```

* Se o SGBD falhar ou for desconhecido, retorna TEXT como fallback seguro. Como j√° explicado em python.

---

### ‚öñÔ∏è Compara√ß√£o entre Python e PHP

| Caracter√≠stica                     | Python                                         | PHP                                               |
| ---------------------------------- | ---------------------------------------------- | ------------------------------------------------- |
| Tipos Detectados                   | Booleano, Data, Inteiro, Float, Texto          | Apenas Num√©rico e Texto                           |
| Sofistica√ß√£o                       | Alta (an√°lise detalhada, regras de formata√ß√£o) | Simples (s√≥ `is_numeric` e verifica√ß√£o de string) |
| Suporte a Zeros √† esquerda         | Sim                                            | **N√£o**                                               |
| Detec√ß√£o de Data                   | Sim (ISO + tentativa com parser)               | **N√£o**                                               |
| Similaridade com √Årvore de Decis√£o | Alta (multi-condicional com contagem de pesos) | Baixa (condicional bin√°ria)                       |
| Configura√ß√£o de Tipo por SGBD      | Sim                                            | Sim                                               |
| Fallback Seguro                    | Sim (retorna TEXT se d√∫vida)                   | Sim                                               |

---

### üìö Notas sobre ``detect_column_type()``

Ambas as vers√µes da fun√ß√£o refletem conceitos de classifica√ß√£o por regras claras e expl√≠citas. Especialmente o Python, que age mediante uma √°rvore de decis√£o simples, permitindo decidir tipos com base em regras fixas mais completas, o que √© excelente para dados estruturados com padr√µes reconhec√≠veis. O que tamb√©m guardam apesar de suas simplicidades (tanto em python, quanto em PHP) uma escalabilidade real e mensur√°vel. Que pode ser aferida e comparada com outras propostas para este fim, a n√≠vel de produ√ß√£o. Atrav√©s de um print de desempenho (dispon√≠vel na vers√£o completa de ambos os scripts).

Algumas caracter√≠sticas como **N√£o**, na **[Tabela de  Compara√ß√£o](#-compara√ß√£o-entre-python-e-php)**:
_Note que **as implementa√ß√µes em python n√£o foram completamente espelhadas** em PHP, por mera pontualidade do desenvolvedor, que preferiu ser arbitrariamente breve neste ponto (disparidade esta, n√£o motivada por quaisquer impedimentos ou limita√ß√µes da linguagem). Haja visto que isto n√£o impede ou limita a observa√ß√£o, analise e exibi√ß√£o pr√°tica dos conceitos expostos. Observados de forma mais completa, adiante._ 

---
<br> &nbsp; 



# SCRIPTS COMPLETOS (Python & PHP)

## Descri√ß√£o

Ambos os scripts t√™m como objetivo facilitar a convers√£o de arquivos CSV em instru√ß√µes SQL compat√≠veis com bancos de dados MySQL ou PostgreSQL, exibindo de forma pr√°tica, a proposta e conceitos abordados anteriormente. O primeiro script √© escrito em Python e o segundo em PHP. Ambos possuem funcionalidades semelhantes, mas com diferen√ßas na implementa√ß√£o, depend√™ncias e ambientes de execu√ß√£o.

## Como usar

### Python

1.  Para rodar o script em Python, utilize o comando:
    
    Para uso de forma interativa:
    ```bash
    source ~/.bashrc; python csv_to_sql.py 
    
    ```
    
    Ou, para uma convers√£o direta:
    
    ```bash
    source ~/.bashrc; python csv_to_sql.py "seu_arquivo.csv" 
    
    ```
    
    E, caso queira especificar o nome da tabela diretamente:
    
    ```bash
    source ~/.bashrc; python csv_to_sql.py "seu_arquivo.csv" "nome_da_tabela"
    
    ```
    

### PHP

1.  Para rodar o script em PHP, utilize o comando:

    Para uso de forma interativa:
    ```bash
    source ~/.bashrc; php csv_to_sql.php
    
    ```
    
    Ou, para uma convers√£o direta:
    
    ```bash
    source ~/.bashrc; php csv_to_sql.php "seu_arquivo.csv"
    
    ```
    
    E, caso queira especificar o nome da tabela diretamente:
    
    ```bash
    source ~/.bashrc; php csv_to_sql.php "seu_arquivo.csv" "nome_da_tabela"
    
    ```
    **NOTA:** 
    Recomenda-se a limpeza do terminal, para melhor visualiza√ß√£o dos retornos. Por isso o acr√©scimo de 
    ```bash
    source ~/.bashrc
    ```
    resultando em um reload do bash.

----------


## Detalhamento dos Scripts

A seguir, observaremos as fun√ß√µes de ambos os scripts (Python e PHP), explicando a l√≥gica e o que acontece em cada parte. Como ambos os scripts tamb√©m se prestam a um fim did√°tico. Algumas das descri√ß√µes consideradas chave, tamb√©m est√£o presentes no pr√≥prio script. Afim de auxiliar, os mais iniciantes, curiosos e estudantes do tema:

----------

### **Script Python (`csv_to_sql.py`)**

#### 1. Importa√ß√£o de Bibliotecas

```python
import os
import sys
import csv
import re
from datetime import datetime
from dateutil.parser import parse as parse_date
import time

```

-   **os**: Usado para manipula√ß√µes no sistema de arquivos, como verificar a exist√™ncia de arquivos ou diret√≥rios.
    
-   **sys**: Usado para acessar os argumentos da linha de comando e outras vari√°veis de ambiente.
    
-   **csv**: Fornece fun√ß√µes para leitura e escrita de arquivos CSV.
    
-   **re**: M√≥dulo de express√µes regulares para manipula√ß√£o de strings.
    
-   **datetime**: Para manipula√ß√£o de datas e formata√ß√£o de timestamps.
    
-   **dateutil.parser**: Biblioteca externa que oferece fun√ß√µes robustas para detectar e parsear datas de diversos formatos.
    
-   **time**: Para medir o tempo de execu√ß√£o do script.
    

#### 2. Configura√ß√µes Iniciais

```python
SGBD = "postgres"
rView = 5
batchSize = 500
outputPath = "/app/backups/"

```

Aqui, s√£o definidas as configura√ß√µes padr√£o, como o tipo de SGBD (Postgres ou MySQL), o n√∫mero de linhas para visualiza√ß√£o preliminar (`rView`), o tamanho dos lotes de inser√ß√£o (`batchSize`) e o diret√≥rio de sa√≠da dos arquivos gerados (`outputPath`).

#### 3. Fun√ß√£o `normalize_name(name)`

```python
def normalize_name(name):
    name = name.strip().lower()
    name = re.sub(r'[^\w\s]', '', name)
    name = re.sub(r'[\s\-\.]+', '_', name)
    return name

```

Esta fun√ß√£o serve para normalizar o nome de colunas e tabelas. Ela remove espa√ßos, acentos, pontua√ß√µes e converte os caracteres para min√∫sculas. O objetivo √© garantir que o nome da tabela ou coluna esteja no formato adequado para SQL, com caracteres simples e sem espa√ßos.

#### 4. Fun√ß√£o `detect_delimiter(file_path)`

```python
def detect_delimiter(file_path):
    delimiters = [",", ";", "\t", "|"]
    with open(file_path, 'r', encoding='utf-8') as f:
        line = f.readline()
        results = {d: len(line.split(d)) for d in delimiters}
    return max(results, key=results.get)

```

Esta fun√ß√£o detecta automaticamente o delimitador do arquivo CSV, verificando qual √© o mais comum em uma linha do arquivo (pode ser v√≠rgula, ponto e v√≠rgula, tabula√ß√£o ou pipe).

#### 5. Fun√ß√£o `detect_column_type(values, sgbd)`

```python
def detect_column_type(values, sgbd):
    bool_set = {'true', 'false', 'yes', 'no', 'sim', 'n√£o', '0', '1'}
    non_empty_values = [v.strip().lower() for v in values if v.strip()]
    type_balance = {'boolean': 0, 'date': 0, 'integer': 0, 'float': 0, 'text': 0}
    for v in non_empty_values:
        if v in bool_set:
            type_balance['boolean'] += 1
        elif v.lstrip('0') != v and len(v) > 1:
            type_balance['text'] += 1
        elif v.replace(',', '.').replace('.', '', 1).isdigit():
            type_balance['float' if '.' in v or ',' in v else 'integer'] += 1
        elif re.match(r'^\d{4}-\d{2}-\d{2}$', v):
            type_balance['date'] += 1
        else:
            try:
                parse_date(v, dayfirst=True)
                type_balance['date'] += 1
            except:
                type_balance['text'] += 1
    best_type = max(type_balance, key=type_balance.get) if len(non_empty_values) == 0 or type_balance[max(type_balance, key=type_balance.get)] / len(non_empty_values) >= 0.8 else 'text'
    return {
        'mysql': {'boolean': 'BOOLEAN', 'date': 'DATE', 'integer': 'INT', 'float': 'FLOAT', 'text': 'TEXT'},
        'postgres': {'boolean': 'BOOLEAN', 'date': 'DATE', 'integer': 'INTEGER', 'float': 'REAL', 'text': 'TEXT'}
    }.get(sgbd, {}).get(best_type, 'TEXT')

```

Essa fun√ß√£o √© respons√°vel por determinar o tipo de dados de uma coluna com base nos valores encontrados. Ela classifica os dados como booleano, data, inteiro, flutuante ou texto, dependendo dos padr√µes de valor encontrados nas c√©lulas. Conforme j√° explicado no inicio deste documento.

#### 6. Fun√ß√£o `prompt(message)`

```python
def prompt(message):
    return input(message).strip()

```

Aqui, a fun√ß√£o `prompt()` exibe uma mensagem para o usu√°rio e captura a entrada fornecida.

#### 7. Fun√ß√£o `preview_csv(file_path, delimiter, limit)`

```python
def preview_csv(file_path, delimiter, limit):
    with open(file_path, 'r', encoding='utf-8') as f:
        reader = csv.reader(f, delimiter=delimiter)
        print(f"\n\n\033[37;44m PR√â-VISUALIZA√á√ÉO DOS DADOS \033[0m (m√°ximo {limit} linhas):")
        for i, row in enumerate(reader):
            print(" | ".join(row))
            if i + 1 >= limit:
                break

```

Essa fun√ß√£o exibe uma pr√©-visualiza√ß√£o das primeiras linhas do arquivo CSV. √â √∫til para confirmar se o arquivo foi lido corretamente antes de seguir com a convers√£o.

#### 8. Fun√ß√£o `main()`

```python
def main():
    args = sys.argv
    ...

```

√â onde todos os processos s√£o iniciados e encapsulados. Ela come√ßa capturando os argumentos passados pela linha de comando, determinando o nome do arquivo CSV, o nome da tabela e o delimitador. Ap√≥s isso, a fun√ß√£o gera o arquivo SQL de acordo com os tipos de banco de dados especificados e insere os dados no formato correto.

--- 
<br> &nbsp; 

### **Script PHP (`csv_to_sql.php`)**

Contem as fun√ß√µes e a l√≥gica do script, em vers√£o PHP.

#### 1. Defini√ß√£o de Configura√ß√µes

```php
$SGBD = "postgres";          // "postgres" | "mysql"
$rView = 5;                  // Linhas em preview
$batchSize = 500;            // Blocos de insert
$outpuPath = "/app/backups/"; // pasta de sa√≠da

```

Assim como no script Python, o script PHP tamb√©m define configura√ß√µes iniciais, como o tipo de SGBD (Postgres ou MySQL), o n√∫mero de linhas para visualiza√ß√£o preliminar (`rView`), o tamanho dos lotes de inser√ß√£o (`batchSize`) e o diret√≥rio de sa√≠da dos arquivos gerados (`outputPath`).

#### 2. Fun√ß√£o `normalize_name($name)`

```php
function normalize_name($name) {
    $name = strtolower(trim($name));
    $name = preg_replace('/[^\w\s]/', '', $name);
    $name = preg_replace('/[\s\-\.]+/', '_', $name);
    return $name;
}

```

Essa fun√ß√£o em PHP tem o mesmo objetivo que a vers√£o Python: normalizar o nome da tabela ou coluna, removendo espa√ßos, acentos e pontua√ß√µes, e convertendo os caracteres para min√∫sculas.

#### 3. Fun√ß√£o `detect_delimiter($filePath)`

```php
function detect_delimiter($filePath) {
    $delimiters = [",", ";", "\t", "|"];
    $line = fgets(fopen($filePath, 'r'));
    $results = [];
    foreach ($delimiters as $delimiter) {
        $fields = str_getcsv($line, $delimiter);
        $results[$delimiter] = count($fields);
    }
    arsort($results);
    return array_key_first($results);
}

```

No PHP, essa fun√ß√£o tamb√©m detecta automaticamente o delimitador usado no arquivo CSV, assim como o script Python. Ela analisa uma linha do arquivo e escolhe o delimitador mais comum.

#### 4. Fun√ß√£o `detect_column_type($values, $SGBD)`

```php
function detect_column_type($values, $SGBD) {
    $isNumeric = true;
    $isText = false;
    foreach ($values as $value){
        if (is_numeric($value)) continue;
        $isNumeric = false;
        if (strlen($value) > 0) $isText = true;
    }
    if ($SGBD == "mysql"){ 
        return $isNumeric ? 'INT' : ($isText ? 'VARCHAR(255)' : 'TEXT'); 
    } elseif ($SGBD == "postgres"){ 
        return $isNumeric ? 'INTEGER' : ($isText ? 'VARCHAR(255)' : 'TEXT');
    } else { 
        return 'TEXT'; 
    }
}

```

A fun√ß√£o `detect_column_type` no PHP segue um racioc√≠nio semelhante √† vers√£o Python, determinando o tipo de dados da coluna com base nos valores encontrados. A diferen√ßa est√° na l√≥gica de verifica√ß√£o e na escolha do tipo de dados com base no SGBD.

#### 5. Fun√ß√£o `prompt($message)`

```php
function prompt($message){
    echo $message;
    return trim(fgets(STDIN));
}

```

Essa fun√ß√£o exibe uma mensagem ao usu√°rio e captura sua entrada, assim como o `prompt` do Python.

#### 6. Fun√ß√£o `main()`

```php
if ($argc === 1) {
    ...
}

```

Assim como o script Python
, o script PHP possui uma fun√ß√£o principal que encapsula os fluxos de execu√ß√£o, captura os par√¢metros da linha de comando e chama as fun√ß√µes necess√°rias para gerar o arquivo SQL de inser√ß√£o. Embora n√£o obrigat√≥ria, esta pr√°tica visa facilitar a manuten√ß√£o, monitoramento de desempenho e edi√ß√µes.

----------

### **L√≥gica Geral**

Tanto o script Python quanto o PHP seguem uma l√≥gica similar:

1.  O script l√™ o arquivo CSV e detecta o delimitador utilizado.
    
2.  A primeira linha do CSV √© processada para determinar os nomes das colunas.
    
3.  A partir de uma amostra, o script determina o tipo de dado (se √© texto, inteiro, etc.) e o classifica em uma coluna.

4.  O script gera uma instru√ß√£o SQL para a cria√ß√£o da tabela no banco de dados (se ele j√° n√£o existir), considerando os tipos de dados em uma inser√ß√£o segura (composta de blocos at√¥micos).

5. O arquivo SQL gerado √© salvo no diret√≥rio de sa√≠da especificado. 

6. Ao carregar o Script SQL resultante. Os dados ser√£o lidos em blocos/lotes (`batchSize de forma serial`) e inseridos na tabela SQL gerada, conforme regra de TRANSACT, contribuindo com o ACID (se praticado pelo time e aceito pelo SGBD).
    

----------

## Conclus√£o e observa√ß√µes:

Ambos os scripts t√™m como objetivo facilitar a integra√ß√£o de dados em bancos de dados MySQL e PostgreSQL, oferecendo ao usu√°rio **uma ferramenta simples, mas poderosa, para automa√ß√£o, auditoria de importa√ß√£o de dados**.
_Este projeto n√£o oferece nenhuma cr√≠tica ou restri√ß√£o ao uso da biblioteca Pandas, quanto a manipula√ß√£o de dados em ambiente python._ Ao contr√°rio, ele pretende (entre outros objetivos) ilustrar o que muitas vezes ocorre longe dos olhos dos que a utilizam. Se prestando a diversas outras funcionalidades, al√©m do tipo classifica√ß√£o, manipula√ß√£o e cataloga√ß√£o de dados, descritas aqui. 
Embora ambos os scripts tenham sido criados para **uso em ambientes de produ√ß√£o, permanecem sendo um conceito** particular. O que significa, n√£o ser nenhum exagero recomendar a familiariza√ß√£o, analise e uso pr√©dio em ambientes controlados como os de homologa√ß√£o, desenvolvimento, de estudo e testes. Afim de que o uso adequado, corresponda as expectativas de seus utilizadores. Enfatizando a import√¢ncia de que, mais do que se utilizar de bibliotecas e scripts pr√°ticos, √© preciso compreende-los. Com a mesma compreens√£o e a humildade, de que nem mesmo a mat√©ria s√≥lida, √© capaz de chegar ao zero absoluto.



<br> &nbsp; 
## AUTOR:

**Autor:** Sr. Victor Batista  
**GitHub:** [https://github.com/srvictorbatista](https://github.com/srvictorbatista)  
**LinkedIn:** [https://linkedin.com/in/levymac](https://linkedin.com/in/levymac)  
**Contato no Telegram:** [@LevyMac](https://t.me/levymac)

<br> &nbsp;
## REPOSIT√ìRIO / CONTRIBUI√á√ïES / LICEN√áA / REPORTs:

- **GitHub:** [https://github.com/srvictorbatista/CSVtoSQL-PNCA](https://github.com/srvictorbatista/CSVtoSQL-PNCA)
- **Licen√ßa:** [MIT](https://opensource.org/licenses/MIT) ‚Äì Uso livre sem limita√ß√µes no estado em que se encontra, com a preserva√ß√£o da autoria.

Contribui√ß√µes s√£o bem-vindas! Caso deseje melhorar este projeto, fique √† vontade para abrir uma **issue** ou **pull request** no reposit√≥rio acima.
Para **reportar falhas, melhorias ou observa√ß√µes adicionais**. Por favor, entre em **[contato com o autor](#autor)**. 

---

**Licen√ßa MIT para uso livre no estado em que se encontra, preservada a autoria.**
